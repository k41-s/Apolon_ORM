using Apolon.Core.ORM.Configuration;
using Apolon.Core.ORM.Database;
using Npgsql;
using System.Data;

namespace Apolon.Core.ORM.Data
{
    public class GenericRepository<T> : IGenericRepository<T> where T : new()
    {
        private readonly DatabaseService? _dbService;
        private readonly ModelMetadata _metadata;
        private readonly PropertyMetadata _pk;

        private readonly NpgsqlConnection? _externalConnection;
        private readonly NpgsqlTransaction? _externalTransaction;

        public GenericRepository(DatabaseService dbService)
        {
            _dbService = dbService;
            _metadata = ModelParser.GetMetadata<T>();

            _pk = _metadata.Properties.FirstOrDefault(p => p.IsPrimaryKey)
                ?? throw new InvalidOperationException(
                    $"Model {_metadata.TableName} has no primary key defined.");
        }

        // Unit of work mode
        public GenericRepository(NpgsqlConnection connection, NpgsqlTransaction? transaction)
        {
            _externalConnection = connection;
            _externalTransaction = transaction;
            _dbService = null;

            _metadata = ModelParser.GetMetadata<T>();
            _pk = _metadata.Properties.FirstOrDefault(p => p.IsPrimaryKey)
                ?? throw new InvalidOperationException($"Model {_metadata.TableName} has no primary key defined.");
        }

        private async Task<(NpgsqlConnection Connection, bool ShouldDispose)> GetConnectionAsync()
        {
            if (_externalConnection != null)
            {
                return (_externalConnection, false);
            }

            if (_dbService != null)
            {
                return (await _dbService.GetNewOpenConnectionAsync(), true);
            }

            throw new InvalidOperationException("Repository is not initialized correctly.");
        }

        private T MapEntityFromReader(NpgsqlDataReader reader)
        {
            var entity = new T();

            foreach (var propMeta in _metadata.Properties)
            {
                var propInfo = typeof(T).GetProperty(propMeta.PropertyName)!;

                int ordinal;
                try
                {
                    ordinal = reader.GetOrdinal(propMeta.ColumnName);
                }
                catch (IndexOutOfRangeException)
                {
                    continue;
                }

                if (!reader.IsDBNull(ordinal))
                {
                    var value = reader.GetValue(ordinal);

                    var targetType = Nullable.GetUnderlyingType(propInfo.PropertyType) ?? propInfo.PropertyType;

                    var convertedValue = Convert.ChangeType(value, targetType);

                    propInfo.SetValue(entity, convertedValue);
                }
            }
            return entity;
        }

        public async Task AddAsync(T entity)
        {
            var insertableProps = _metadata.Properties.Where(p => !p.IsAutoGenerated).ToList();

            if (!insertableProps.Any())
            {
                throw new InvalidOperationException($"Cannot insert into {_metadata.TableName}: No insertable columns found.");
            }

            var columns = string.Join(", ", insertableProps.Select(p => p.ColumnName));
            var parameters = string.Join(", ", insertableProps.Select(p => $"@{p.PropertyName}"));

            var sql = $"INSERT INTO {_metadata.TableName} ({columns}) VALUES ({parameters}) RETURNING {_pk.ColumnName}";

            var (connection, shouldDispose) = await GetConnectionAsync();
            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);

                foreach (var propMeta in insertableProps)
                {
                    var propInfo = typeof(T).GetProperty(propMeta.PropertyName)!;
                    var value = propInfo.GetValue(entity);

                    var paramValue = value;
                    if (value != null)
                    {
                        var propType = propInfo.PropertyType;
                        var underlyingType = Nullable.GetUnderlyingType(propType) ?? propType;

                        if (underlyingType.IsEnum)
                        {
                            paramValue = value.ToString();
                        }
                    }

                    command.Parameters.AddWithValue($"@{propMeta.PropertyName}", value ?? DBNull.Value);
                }

                var newId = await command.ExecuteScalarAsync();

                if (newId != null)
                {
                    var pkPropInfo = typeof(T).GetProperty(_pk.PropertyName)!;
                    var convertedId = Convert.ChangeType(newId, pkPropInfo.PropertyType);
                    pkPropInfo.SetValue(entity, convertedId);
                }
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task UpdateAsync(T entity)
        {
            var updatableProps = _metadata.Properties
                .Where(p => !p.IsPrimaryKey)
                .ToList();
            if (!updatableProps.Any())
            {
                throw new InvalidOperationException($"Cannot update {_metadata.TableName}: No updatable columns found.");
            }
            var setClauses = string.Join(", ",
                updatableProps.Select(p => $"{p.ColumnName} = @{p.PropertyName}"));

            var sql = $"UPDATE {_metadata.TableName} SET {setClauses} WHERE {_pk.ColumnName} = @{_pk.PropertyName}";
            
            var (connection, shouldDispose) = await GetConnectionAsync();
            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);

                foreach (var propMeta in updatableProps)
                {
                    var propInfo = typeof(T).GetProperty(propMeta.PropertyName)!;
                    var value = propInfo.GetValue(entity);

                    var paramValue = value;
                    if (value != null)
                    {
                        var propType = propInfo.PropertyType;
                        var underlyingType = Nullable.GetUnderlyingType(propType) ?? propType;

                        if (underlyingType.IsEnum)
                        {
                            paramValue = value.ToString();
                        }
                    }

                    command.Parameters.AddWithValue($"@{propMeta.PropertyName}", value ?? DBNull.Value);
                }

                var pkPropInfo = typeof(T).GetProperty(_pk.PropertyName)!;
                var pkValue = pkPropInfo.GetValue(entity);

                command.Parameters.AddWithValue(
                    $"{_pk.PropertyName}",
                    pkValue ?? throw new InvalidOperationException("Cannot update entity with a null primary key."));

                await command.ExecuteNonQueryAsync();
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task DeleteAsync(object id)
        {
            var sql = $"DELETE FROM {_metadata.TableName} WHERE {_pk.ColumnName} = @id";

            var (connection, shouldDispose) = await GetConnectionAsync();
            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);

                command.Parameters.AddWithValue("id", id);

                await command.ExecuteNonQueryAsync();
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task<IEnumerable<T>> GetAllAsync()
        {
            var results = new List<T>();

            var columnList = string.Join(", ", _metadata.Properties.Select(p => p.ColumnName));
            var sql = $"SELECT {columnList} FROM {_metadata.TableName}";

            var (connection, shouldDispose) = await GetConnectionAsync();
            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);
                await using var reader = await command.ExecuteReaderAsync();
                while (await reader.ReadAsync()) results.Add(MapEntityFromReader(reader));
                return results;
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task<T?> GetByIdAsync(object id)
        {
            var columnList = string.Join(", ", _metadata.Properties.Select(p => p.ColumnName));
            var sql = $"SELECT {columnList} FROM {_metadata.TableName} WHERE {_pk.ColumnName} = @id LIMIT 1";

            var (connection, shouldDispose) = await GetConnectionAsync();

            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);

                command.Parameters.AddWithValue("id", id);

                await using var reader = await command.ExecuteReaderAsync();

                if (await reader.ReadAsync())
                    return MapEntityFromReader(reader);

                return default;
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task<IEnumerable<T>> GetAsync(
            string? whereClause = null, 
            object? queryParams = null, 
            string? orderBy = null)
        {
            var results = new List<T>();

            var columnList = string.Join(", ", _metadata.Properties.Select(p => p.ColumnName));
            var sql = $"SELECT {columnList} FROM {_metadata.TableName}";

            if (!string.IsNullOrWhiteSpace(whereClause))
                sql += $" WHERE {whereClause}";

            if (!string.IsNullOrWhiteSpace(orderBy))
                sql += $" ORDER BY {orderBy}";

            var (connection, shouldDispose) = await GetConnectionAsync();

            try
            {
                await using var command = new NpgsqlCommand(sql, connection, _externalTransaction);

                if (queryParams != null)
                {
                    var properties = queryParams.GetType().GetProperties();
                    foreach (var prop in properties)
                    {
                        var value = prop.GetValue(queryParams);
                        command.Parameters.AddWithValue($"@{prop.Name}", value ?? DBNull.Value);
                    }
                }

                await using var reader = await command.ExecuteReaderAsync();

                while (await reader.ReadAsync())
                {
                    results.Add(MapEntityFromReader(reader));
                }

                return results;
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        public async Task<IEnumerable<T>> GetWithRelationsAsync(
            string[] includeProperties,
            string? whereClause = null,
            object? queryParams = null
        ) {
            var results = new List<T>();

            var (sql, relatedMetadataMap) = BuildSqlWithJoins(includeProperties, whereClause);

            var (connection, shouldDispose) = await GetConnectionAsync();
            try
            {
                await using var command = new NpgsqlCommand(
                    sql, 
                    connection, 
                    _externalTransaction
                );

                if (queryParams != null)
                {
                    foreach (var prop in queryParams.GetType().GetProperties())
                        command.Parameters.AddWithValue(
                            $"@{prop.Name}", 
                            prop.GetValue(queryParams) ?? DBNull.Value
                        );
                }

                await using var reader = await command.ExecuteReaderAsync();

                while (await reader.ReadAsync())
                {
                    var entity = MapEntityWithRelationsFromReader(
                        reader, 
                        includeProperties, 
                        relatedMetadataMap
                    );
                    results.Add(entity);
                }
                return results;
            }
            finally
            {
                if (shouldDispose) await connection.DisposeAsync();
            }
        }

        private (string Sql, Dictionary<string, ModelMetadata> RelatedMetadataMap) BuildSqlWithJoins(
            string[] includeProperties,
            string? whereClause
        ) {
            var mainTable = _metadata.TableName;
            var selectColumns = new List<string>();
            var joinClauses = new List<string>();
            var relatedMetadataMap = new Dictionary<string, ModelMetadata>();

            foreach (var p in _metadata.Properties)
                selectColumns.Add($"{mainTable}.{p.ColumnName} AS {mainTable}_{p.ColumnName}");

            foreach (var propName in includeProperties)
            {
                var propInfo = typeof(T).GetProperty(propName)
                    ?? throw new ArgumentException($"Property {propName} not found on {typeof(T).Name}");

                var relatedType = propInfo.PropertyType;
                var relatedMetadata = ModelParser.GetMetadata(relatedType);
                relatedMetadataMap.Add(propName, relatedMetadata);

                var fkProp = _metadata.Properties.FirstOrDefault(p => p.PropertyName == $"{propName}Id");

                if (fkProp == null)
                    throw new InvalidOperationException($"Could not determine FK for navigation property {propName}. Convention failed.");

                var relatedTable = relatedMetadata.TableName;
                var relatedPk = relatedMetadata.Properties.First(p => p.IsPrimaryKey);

                joinClauses.Add($"LEFT JOIN {relatedTable} ON {mainTable}.{fkProp.ColumnName} = {relatedTable}.{relatedPk.ColumnName}");

                foreach (var rp in relatedMetadata.Properties)
                    selectColumns.Add($"{relatedTable}.{rp.ColumnName} AS {relatedTable}_{rp.ColumnName}");
            }

            var sql = $"SELECT {string.Join(", ", selectColumns)} FROM {mainTable} {string.Join(" ", joinClauses)}";

            if (!string.IsNullOrWhiteSpace(whereClause))
                sql += $" WHERE {whereClause}";

            return (sql, relatedMetadataMap);
        }

        private T MapEntityWithRelationsFromReader(
            NpgsqlDataReader reader,
            string[] includeProperties,
            Dictionary<string, ModelMetadata> relatedMetadataMap
        ) {
            var mainTable = _metadata.TableName;

            var entity = MapEntityFromAliasedReader(reader, _metadata, mainTable);

            foreach (var propName in includeProperties)
            {
                var propInfo = typeof(T).GetProperty(propName)!;
                var relatedType = propInfo.PropertyType;
                var relatedMetadata = relatedMetadataMap[propName];
                var relatedTable = relatedMetadata.TableName;

                var pkColAlias = $"{relatedTable}_{relatedMetadata.Properties.First(p => p.IsPrimaryKey).ColumnName}";
                var pkOrdinal = reader.GetOrdinal(pkColAlias);

                if (!reader.IsDBNull(pkOrdinal))
                {
                    var relatedEntity = MapEntityFromAliasedReader(reader, relatedMetadata, relatedTable, relatedType);
                    propInfo.SetValue(entity, relatedEntity);
                }
            }

            return entity;
        }

        private T MapEntityFromAliasedReader(NpgsqlDataReader reader, ModelMetadata metadata, string tablePrefix)
        {
            return (T)MapEntityFromAliasedReader(reader, metadata, tablePrefix, typeof(T));
        }

        private object MapEntityFromAliasedReader(NpgsqlDataReader reader, ModelMetadata metadata, string tablePrefix, Type type)
        {
            var entity = Activator.CreateInstance(type)!;
            foreach (var prop in metadata.Properties)
            {
                var alias = $"{tablePrefix}_{prop.ColumnName}";
                try
                {
                    var ordinal = reader.GetOrdinal(alias);
                    if (!reader.IsDBNull(ordinal))
                    {
                        var val = reader.GetValue(ordinal);
                        var propInfo = type.GetProperty(prop.PropertyName)!;
                        var targetType = Nullable.GetUnderlyingType(propInfo.PropertyType) ?? propInfo.PropertyType;
                        propInfo.SetValue(entity, Convert.ChangeType(val, targetType));
                    }
                }
                catch (IndexOutOfRangeException) 
                { 
                    /* Ignore missing columns */ 
                }
            }
            return entity;
        }
    }
}
